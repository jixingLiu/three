<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>bar chart</title>
    <script src='../js/jquery.min.js'></script>
    <script src="../js/three.min.js"></script>
    <script src="../js/OrbitControls.js"></script>
    <style>
        body {
            color: #808080;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;

            background-color: #ccc;
            margin: 0px;
            overflow: hidden;
        }

        .addData {
            width: 60px;
            height: 30px;
            position: absolute;
            top: 10px;
            text-align: center;
            border: 1px solid #fff;
            border-radius: 5px;
            line-height: 30px;
            color: #00f;
            display: none;
        }
    </style>
</head>

<body>
    <canvas id="canvas0"></canvas>
    <canvas id="canvas1"></canvas>
    <canvas id="canvas2"></canvas>
    <canvas id="canvas3"></canvas>
    <script>
        var cube = [];
        var SCREEN_WIDTH = window.innerWidth;
        var SCREEN_HEIGHT = window.innerHeight;
        var aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
        var cameraRig, activeCamera, activeHelper;
        var cameraPerspective, cameraOrtho;
        var cameraPerspectiveHelper, cameraOrthoHelper;
        var frustumSize = 600;

        var data = [10, 60, 40, 50, 30, 20, 10];
        var len = data.length;
        var container;
        var camera, scene, renderer, mesh;
        var canvas = Array.of();
        var ctx = Array.of();
        var texture = Array.of();
        for (let i = 0; i < 4; i++) {
            canvas[i] = document.getElementById(`canvas${i}`);
            canvas[i].style.display = 'none';
            ctx[i] = canvas[i].getContext('2d');
            if (i == 0) {
                canvas[i].width = 450;
                canvas[i].height = 300;
                ctx[0].translate(0, 300);
                for (let i = 0; i < 10; i++) {
                    if (i % 2 == 0) {
                        ctx[0].fillStyle = '#08aeec';
                    } else {
                        ctx[0].fillStyle = '#096bc4';
                    }
                    ctx[0].fillRect(0, -300 / 10 * i, 450, 300 / 10);
                    ctx[0].save();
                    ctx[0].fillStyle = '#ffffff';
                    ctx[0].font = "12px Georgia";
                    ctx[0].fillText(`${i * 10}`, 0, -300 / 10 * i + 10);
                }
            }
            if (i == 1) {
                for (let j = 0; j < len; j++) {
                    if (j % 2 == 0) {
                        ctx[i].fillStyle = '#e5e4e4';
                    } else {
                        ctx[i].fillStyle = '#fcfcfc';
                    }
                    ctx[i].fillRect(300 / len * j + 2, 0, 300 / len, 150);
                    ctx[i].save();
                    ctx[i].fillStyle = '#08AEEC';
                    ctx[i].font = "12px Georgia";
                    ctx[i].fillText(`${3 + j}月`, 300 / len * j + 10, 140)
                }
            }
            if (i == 2) {
                canvas[i].width = 30;
                canvas[i].height = 40;
                for (let j = 0; j < len; j++) {
                    ctx[i].fillStyle = "#B5C0CD";
                    ctx[i].fillRect(0, 0, 30, 40)
                    ctx[i].fillStyle = '#3B2A2B';
                    ctx[i].font = "12px Georgia";
                    ctx[i].fillText(`${data[j]}`, 8, 22);
                    ctx[i].save();
                }
            }
            if (i == 3) {
                canvas[i].width = 300;
                canvas[i].height = 150;
                ctx[i].fillStyle = "#cfcfcf";
                ctx[i].fillRect(0, 0, 300, 150)
                ctx[i].fillStyle = '#000000';
                ctx[i].font = "22px Georgia";
                ctx[i].fillText(`标题`, 12, 60);
                ctx[i].save();
            }
            texture[i] = new THREE.Texture(canvas[i]);
            texture[i].needsUpdate = true
        }

        // console.log(ctx[0], 9999)
        init();
        animate();
        function init() {
            // 创建容器并添加场景
            container = document.createElement('div');
            document.body.appendChild(container);
            scene = new THREE.Scene();
            scene.position.y = -100;

            // 辅助坐标
            axes = new THREE.AxisHelper(1000);
            scene.add(axes);

            // 创建相机
            camera = new THREE.PerspectiveCamera(50, 0.5 * aspect, 1, 1000);
            // camera.position.z = 120;
            // camera.position.y = 10;
            // camera.position.x = -20;
            camera.position.set(80, 30, 80);

            //创建相机及其辅助相机
            cameraPerspective = new THREE.PerspectiveCamera(70, 0.5 * aspect, 150, 1000);
            cameraPerspectiveHelper = new THREE.CameraHelper(cameraPerspective);
            scene.add(cameraPerspectiveHelper);

            // 创建矩形相机
            cameraOrtho = new THREE.OrthographicCamera(0.5 * frustumSize * aspect / - 2, 0.5 * frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 150, 1000);
            cameraOrthoHelper = new THREE.CameraHelper(cameraOrtho);
            scene.add(cameraOrthoHelper);

            activeCamera = cameraPerspective;
            activeHelper = cameraPerspectiveHelper;

            //创建灯光
            var point = new THREE.PointLight(0xffffff);
            point.position.set(400, 200, 300);
            scene.add(point);
            var light = new THREE.DirectionalLight(0xffffff);
            light.position.set(100, 100, 100);
            scene.add(light);
            var light = new THREE.DirectionalLight(0xffffff);
            light.position.set(-100, -100, -100);
            scene.add(light);
            var light = new THREE.AmbientLight(0x444444);
            scene.add(light);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
            renderer.domElement.style.position = "relative";
            container.appendChild(renderer.domElement);
            renderer.autoClear = false;
            bg();
            createPlane();
            drawCube();
            window.addEventListener('click', onMouseover, false)
            window.addEventListener('resize', onWindowResize, false);
        }
        // 更新动画
        function animate() {
            loop();
            requestAnimationFrame(animate);
            render();
        }
        // 浏览器窗体发生变化
        function onWindowResize(event) {
            SCREEN_WIDTH = window.innerWidth;
            SCREEN_HEIGHT = window.innerHeight;
            aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
            renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
            camera.aspect = 0.5 * aspect;
            camera.updateProjectionMatrix();
        }
        var flag = true;
        var r = 1;
        function loop() {
            //var r = Date.now() * 0.00002;
            cameraOrtho.rotation.y = Math.PI;
            cameraPerspective.rotation.y = Math.PI;
            cameraRig = new THREE.Group();
            cameraRig.add(cameraPerspective);
            cameraRig.add(cameraOrtho);
            if (r <= 2) {
                r = r + 0.002;
                camera.position.x = Math.cos(r) * 80;
                camera.position.z = Math.sin(r) * 80;
                camera.lookAt(scene.position);          
            } else {
            }
            scene.add(cameraRig);
            if (activeCamera === cameraPerspective) {
                cameraPerspective.fov = 55 + 30 * Math.sin(0.5 * r);
                cameraPerspective.updateProjectionMatrix();
                cameraPerspectiveHelper.update();
                cameraPerspectiveHelper.visible = true;
                cameraOrthoHelper.visible = false;

            } else {
                cameraOrtho.far = mesh.position.length();
                cameraOrtho.updateProjectionMatrix();
                cameraOrthoHelper.update();
                cameraOrthoHelper.visible = true;
                cameraPerspectiveHelper.visible = false;
            }
            renderer.clear();
            activeHelper.visible = false;
            renderer.setViewport(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
            renderer.render(scene, activeCamera);
        }
        // 渲染
        function render() {
            renderer.render(scene, camera);
        }
        // 画背景
        function bg() {
            var geometry = new THREE.Geometry();
            for (var i = 0; i < 5000; i++) {
                var vertex = new THREE.Vector3();
                vertex.x = THREE.Math.randFloatSpread(2000);
                vertex.y = THREE.Math.randFloatSpread(2000);
                vertex.z = THREE.Math.randFloatSpread(2000);
                geometry.vertices.push(vertex);
            }
            var particles = new THREE.Points(geometry, new THREE.PointsMaterial({ color: 0xffffff }));
            scene.add(particles);
        }
        function createPlane() {
            // 创建坐标平面
            var planeGeometry = new THREE.PlaneBufferGeometry(6 * len + 4, 30);
            planeGeometry.rotateX(- Math.PI / 2);
            var planeMaterial = new THREE.MeshBasicMaterial({
                map: texture[1],
                color: 0xF2F2ED, overdraw: 0.5
            });
            plane = new THREE.Mesh(planeGeometry, planeMaterial);
            scene.add(plane);

            // 创建文字演示平面
            var planeGeometry = new THREE.PlaneBufferGeometry(6 * len / 1.5, 10);
            //planeGeometry.rotateX(- Math.PI / 2);
            var planeMaterial = new THREE.MeshBasicMaterial({
                map: texture[3],
                //color: 0xB9B7B5, overdraw: 0.5
            });
            plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.position.z = 22;
            plane.rotateX(-Math.PI / 6);
            plane.position.y = -5;
            scene.add(plane);

            // 后边的图 并画网格
            var planeGeometry = new THREE.PlaneBufferGeometry(6 * len + 4, Math.max(...data));
            var planeMaterial = new THREE.MeshPhongMaterial({
                map: texture[0],
            });
            plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.position.z = - 15;
            plane.position.y = Math.max(...data) / 2;
            scene.add(plane);

        }
        // 画数据展示图
        function drawData() {
            for (let i = 0; i < len; i++) {
                var planeGeometry = new THREE.PlaneBufferGeometry(4, 6);
                var planeMaterial = new THREE.MeshPhongMaterial({
                    map: texture[2],
                });
                plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.position.set((-6 * len / 2 + 6 * i + 3), data[i] - 3, 2.1)
                scene.add(plane);
            }

        }
        // 绘制柱形图
        //var cube = Array.of();
        function drawCube() {
            var materialArr = [
                new THREE.MeshPhongMaterial({ color: 0xff0000 }),
                new THREE.MeshPhongMaterial({ color: 0x0000ff }),
                new THREE.MeshPhongMaterial({ color: 0xff00ff }),
                new THREE.MeshPhongMaterial({ color: 0x00ff00 }),
                new THREE.MeshPhongMaterial({ color: 0xB5C0CD }),
                new THREE.MeshPhongMaterial({ color: 0x00ffff })
            ]
            for (let i = 0; i < len; i++) {
                var facematerial = new THREE.MeshFaceMaterial(materialArr);
                cube[i] = new THREE.Mesh(new THREE.BoxGeometry(4, data[i], 4), facematerial);
                scene.add(cube[i]);

            }
            (function (iv, cube) {
                var timer = setInterval(function () {
                    iv = parseFloat((iv + 0.1).toFixed(2));
                    for (let i = 0; i < cube.length; i++) {
                        cube[i].scale.y = iv;
                        cube[i].position.set((-6 * len / 2 + 6 * i + 3), iv * data[i] / 2, 0);
                        scene.add(cube[i]);
                    }
                    if (iv >= 1) {
                        clearInterval(timer);
                        timer = null;
                        drawData();
                        return;
                    }
                }, 100)
            })(0.1, cube)
        }
        function onMouseover(e) {
            console.log(e, e.clientX, 7676)
            console.log(cube[4].material[4].color = new THREE.Color(0xffff00));
            $('.addData').html(data[3]).css({
                left: e.clientX,
                top: 70,
                display: 'block'
            })

        }
    </script>
    <div class="addData">
        <span>nihao</span>
        
    </div>
</body>

</html>